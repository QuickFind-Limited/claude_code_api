---
description: Security patterns and best practices for Claude SDK Server
globs: ["*.py", "**/*.py"]
alwaysApply: true
---

## Input Validation

- Validate all user inputs
- Whitelist allowed characters
- Length limits on strings
- Size limits on files
- Rate limiting on endpoints
- Sanitize before processing

## Authentication

```python
# JWT token validation
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer

security = HTTPBearer()

async def verify_token(token: str = Depends(security)) -> dict:
    try:
        payload = jwt.decode(
            token.credentials,
            settings.jwt_secret,
            algorithms=["HS256"]
        )
        return payload
    except JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token"
        )
```

## Environment Variables

```python
# Use pydantic for secure config
from pydantic import SecretStr
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    anthropic_api_key: SecretStr
    jwt_secret: SecretStr
    redis_password: SecretStr | None = None
    
    class Config:
        env_file = ".env"
        case_sensitive = False
        
    def get_api_key(self) -> str:
        return self.anthropic_api_key.get_secret_value()
```

## API Key Management

- Never hardcode keys
- Rotate keys regularly
- Use key vaults in production
- Separate keys per environment
- Audit key usage
- Revoke compromised keys

## Rate Limiting

```python
from slowapi import Limiter
from slowapi.util import get_remote_address

limiter = Limiter(
    key_func=get_remote_address,
    default_limits=["100/minute"]
)

@router.post("/completions")
@limiter.limit("10/minute")
async def create_completion(request: ChatRequest):
    # Rate limited endpoint
    pass
```

## Data Sanitization

```python
import bleach
from html import escape

def sanitize_user_input(text: str) -> str:
    # Remove HTML tags
    text = bleach.clean(text, tags=[], strip=True)
    # Escape special characters
    text = escape(text)
    # Limit length
    return text[:10000]

class ChatMessage(BaseModel):
    content: str
    
    @field_validator("content")
    @classmethod
    def sanitize_content(cls, v: str) -> str:
        return sanitize_user_input(v)
```

## Error Handling

- Never expose internal errors
- Log security events
- Generic error messages to users
- Detailed logs for debugging
- Alert on suspicious patterns
- Rate limit error responses

## File Upload Security

```python
ALLOWED_EXTENSIONS = {".png", ".jpg", ".pdf", ".txt"}
MAX_FILE_SIZE = 10 * 1024 * 1024  # 10MB

async def validate_file(file: UploadFile) -> None:
    # Check extension
    ext = Path(file.filename).suffix.lower()
    if ext not in ALLOWED_EXTENSIONS:
        raise HTTPException(400, "Invalid file type")
    
    # Check size
    content = await file.read()
    if len(content) > MAX_FILE_SIZE:
        raise HTTPException(413, "File too large")
    
    # Reset file pointer
    await file.seek(0)
    
    # Scan for malware (example)
    if await scan_for_malware(content):
        raise HTTPException(400, "Suspicious file content")
```

## CORS Configuration

```python
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://trusted-domain.com"],
    allow_credentials=True,
    allow_methods=["GET", "POST"],
    allow_headers=["Authorization", "Content-Type"],
    max_age=3600
)
```

## Logging Security

```python
import logging
from typing import Any

class SecurityFilter(logging.Filter):
    """Remove sensitive data from logs."""
    
    SENSITIVE_FIELDS = {"password", "token", "api_key", "secret"}
    
    def filter(self, record: logging.LogRecord) -> bool:
        if hasattr(record, "args"):
            record.args = self._sanitize(record.args)
        return True
    
    def _sanitize(self, data: Any) -> Any:
        if isinstance(data, dict):
            return {
                k: "***REDACTED***" if k in self.SENSITIVE_FIELDS else v
                for k, v in data.items()
            }
        return data
```

## SQL Injection Prevention

```python
# Use parameterized queries
async def get_user(user_id: str) -> User:
    # Safe - parameterized
    query = "SELECT * FROM users WHERE id = $1"
    result = await db.fetch_one(query, user_id)
    
    # Unsafe - string concatenation
    # query = f"SELECT * FROM users WHERE id = '{user_id}'"
    
    return User(**result)
```

## Dependency Security

- Regular dependency updates
- Security vulnerability scanning
- Pin dependency versions
- Use virtual environments
- Audit third-party packages
- Monitor for CVEs

## Secrets Management

```python
# Use environment variables
api_key = os.environ.get("ANTHROPIC_API_KEY")
if not api_key:
    raise ValueError("API key not configured")

# Use key management service
from azure.keyvault.secrets import SecretClient

client = SecretClient(vault_url, credential)
secret = client.get_secret("anthropic-api-key")
```

## Session Security

- Use secure session IDs
- Session timeout implementation
- Invalidate on logout
- Rotate session IDs
- Store minimal session data
- Use Redis with TTL

## Monitoring & Alerting

- Log authentication failures
- Monitor rate limit violations
- Alert on unusual patterns
- Track API key usage
- Audit sensitive operations
- Security dashboard metrics